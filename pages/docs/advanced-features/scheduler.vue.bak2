<template>
  <div>
    <h1>Task Scheduling</h1>
    <p>Khadem provides a powerful task scheduling system that allows you to schedule and automate recurring tasks, jobs, and background processes.</p>

    <h2>Overview</h2>
    <p>The scheduler allows you to define tasks that run at specific intervals, making it easy to automate maintenance tasks, data processing, email sending, and other background operations.</p>

    <h2>Basic Usage</h2>
    <CodeBlock language="dart" title="Creating a Scheduled Task">
const scheduleUserCleanup = `
// Schedule user cleanup task
class UserCleanupJob implements ScheduledJob &#123;
  @override
  String get name => 'user_cleanup';

  @override
  String get expression => '0 2 * * *'; // Daily at 2 AM

  @override
  Future execute() async &#123;
    // Clean up inactive users
    final inactiveUsers = await User.where('last_login', '<', DateTime.now().subtract(Duration(days: 365))).get();

    for (final user in inactiveUsers) &#123;
      // Archive or delete inactive user
      await user.update(&#123;'status': 'archived'&#125;);
    &#125;

    Logger.info('Cleaned up $&#123;inactiveUsers.length&#125; inactive users');
  &#125;
&#125;
`;
    </CodeBlock>

    <h2>Scheduler Configuration</h2>
    <CodeBlock language="dart" title="Configuring the Scheduler">
const schedulerConfig = `
// Configure scheduler in config/app.dart
class AppConfig &#123;
  static Map&lt;String, dynamic&gt; get scheduler &#123;
    return &#123;
      'timezone': 'UTC',
      'jobs': [
        UserCleanupJob(),
        DatabaseBackupJob(),
        EmailDigestJob(),
      ],
      'workers': 2, // Number of worker processes
      'max_attempts': 3, // Max retry attempts
      'retry_delay': Duration(minutes: 5),
    &#125;;
  &#125;
&#125;
`;
    </CodeBlock>

    <h2>Cron Expressions</h2>
    <p>Khadem uses standard cron expressions to define when tasks should run:</p>
    <CodeBlock language="text" title="Cron Expression Examples">
# Examples of cron expressions
* * * * *     # Every minute
0 * * * *     # Every hour
0 9 * * *     # Daily at 9 AM
0 9 * * 1     # Every Monday at 9 AM
0 9 1 * *     # First day of every month at 9 AM
0 9 1 1 *     # January 1st at 9 AM
    </CodeBlock>

    <h2>Advanced Scheduling</h2>
    <CodeBlock language="dart" title="Advanced Task Scheduling">
const advancedScheduling = `
// Task with dependencies
class ReportGenerationJob implements ScheduledJob &#123;
  @override
  String get name => 'generate_reports';

  @override
  String get expression => '0 6 * * 1'; // Every Monday at 6 AM

  @override
  List&lt;String&gt; get dependencies => ['data_sync', 'user_cleanup'];

  @override
  Future execute() async &#123;
    // Generate weekly reports
    final report = await Report.generateWeekly();

    // Send to stakeholders
    await Mail.send(
      'admin@company.com',
      'Weekly Report',
      'weekly-report',
      &#123;'report': report&#125;
    );
  &#125;
&#125;

// Conditional task execution
class ConditionalJob implements ScheduledJob &#123;
  @override
  String get name => 'conditional_task';

  @override
  String get expression => '0 */4 * * *'; // Every 4 hours

  @override
  Future&lt;bool&gt; shouldExecute() async &#123;
    // Only run if there are pending tasks
    final pendingCount = await Task.where('status', 'pending').count();
    return pendingCount > 0;
  &#125;

  @override
  Future execute() async &#123;
    // Process pending tasks
    final pendingTasks = await Task.where('status', 'pending').limit(10).get();

    for (final task in pendingTasks) &#123;
      await task.process();
    &#125;
  &#125;
&#125;
`;
    </CodeBlock>

    <h2>Task Monitoring</h2>
    <CodeBlock language="dart" title="Monitoring Scheduled Tasks">
const taskMonitoring = `
// Monitor task execution
class TaskMonitor &#123;
  static Future logTaskExecution(String taskName, Duration executionTime, bool success) async &#123;
    await Database.table('task_logs').insert(&#123;
      'task_name': taskName,
      'execution_time': executionTime.inMilliseconds,
      'success': success,
      'executed_at': DateTime.now(),
    &#125;);
  &#125;

  static Future getTaskStats(String taskName) async &#123;
    return await Database.table('task_logs')
      .where('task_name', taskName)
      .where('executed_at', '>', DateTime.now().subtract(Duration(days: 7)))
      .selectRaw('COUNT(*) as total_runs, AVG(execution_time) as avg_time, SUM(CASE WHEN success = 1 THEN 1 ELSE 0 END) as successful_runs')
      .first();
  &#125;
&#125;
`;
    </CodeBlock>

    <h2>Error Handling and Retries</h2>
    <CodeBlock language="dart" title="Task Error Handling">
const errorHandling = `
// Task with retry logic
class RetryableJob implements ScheduledJob &#123;
  @override
  String get name => 'api_sync';

  @override
  String get expression => '*/30 * * * *'; // Every 30 minutes

  @override
  int get maxRetries => 3;

  @override
  Duration get retryDelay => Duration(minutes: 5);

  @override
  Future execute() async &#123;
    try &#123;
      // Attempt API synchronization
      await syncWithExternalAPI();

      Logger.info('API sync completed successfully');
    &#125; catch (e) &#123;
      Logger.error('API sync failed', e);

      // Retry logic is handled automatically by the scheduler
      throw e; // Re-throw to trigger retry
    &#125;
  &#125;

  Future syncWithExternalAPI() async &#123;
    // Implementation for API sync
    final response = await HttpClient().get('https://api.external.com/data');

    if (response.statusCode != 200) &#123;
      throw Exception('API sync failed with status: $&#123;response.statusCode&#125;');
    &#125;

    // Process response data
    final data = jsonDecode(response.body);
    await processSyncedData(data);
  &#125;
&#125;
`;
    </CodeBlock>

    <h2>Task Queues</h2>
    <p>Scheduled tasks can also be queued for asynchronous processing:</p>
    <CodeBlock language="dart" title="Queueing Scheduled Tasks">
const taskQueues = `
// Queue-based task execution
class QueueableJob implements ScheduledJob &#123;
  @override
  String get name => 'heavy_processing';

  @override
  String get expression => '0 1 * * *'; // Daily at 1 AM

  @override
  bool get shouldQueue => true;

  @override
  String get queue => 'processing';

  @override
  Future execute() async &#123;
    // This will be queued instead of executed immediately
    final tasks = await Task.where('status', 'pending').get();

    for (final task in tasks) &#123;
      // Queue individual task processing
      await Queue.dispatch(
        ProcessTaskJob(task.id),
        queue: 'processing'
      );
    &#125;
  &#125;
&#125;
`;
    </CodeBlock>

    <h2>Best Practices</h2>
    <ul>
      <li>Use descriptive task names and expressions</li>
      <li>Implement proper error handling and logging</li>
      <li>Consider resource usage for heavy tasks</li>
      <li>Use appropriate retry strategies</li>
      <li>Monitor task execution and performance</li>
      <li>Test scheduled tasks in development environment</li>
    </ul>
  </div>
</template>

<script setup>
import CodeBlock from '~/components/CodeBlock.vue'
</script>
